<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>新年倒计时 - 绚丽烟花</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Great+Vibes&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            height: 100dvh;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: serif, 'Playfair Display';
            position: relative;
            box-sizing: border-box;
            padding-top: env(safe-area-inset-top);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .content {
            position: relative;
            z-index: 10;
            text-align: center;
            color: #fff;
            pointer-events: none;
            /* 稍微向下偏移，解决视觉重心偏上的问题 */
            transform: translateY(20px);
            mix-blend-mode: screen;
        }
        h1 {
            font-size: clamp(3.2rem, 10vw, 7rem);
            margin: 0;
            font-family: 'Great Vibes', cursive;
            font-weight: 400;
            letter-spacing: clamp(1px, 1vw, 6px);
            background: linear-gradient(135deg, #fff1b8 0%, #ffd700 35%, #ff4d6d 72%, #ffffff 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 16px rgba(255, 215, 0, 0.35)) drop-shadow(0 0 18px rgba(255, 77, 109, 0.25));
            animation: float 6s ease-in-out infinite;
        }
        h2 {
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            margin-top: 10px;
            font-family: 'Playfair Display';
            font-style: italic;
            font-weight: 400;
            letter-spacing: clamp(2px, 2vw, 8px);
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 77, 109, 0.95) 55%, rgba(255, 241, 184, 0.95) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            opacity: 0.9;
            filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.22)) drop-shadow(0 0 12px rgba(255, 77, 109, 0.20));
            animation: glow 3s ease-in-out infinite alternate;
        }

        .music-toggle {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            right: max(12px, env(safe-area-inset-right));
            z-index: 30;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 9999px;
            background: rgba(9, 10, 15, 0.38);
            border: 1px solid rgba(255, 215, 0, 0.35);
            color: rgba(255, 241, 184, 0.95);
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.2px;
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(6px);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            cursor: pointer;
        }

        .music-toggle svg {
            width: 20px;
            height: 20px;
            display: block;
        }

        .music-toggle.is-muted::after {
            content: '';
            position: absolute;
            width: 28px;
            height: 2px;
            background: rgba(255, 241, 184, 0.95);
            transform: rotate(-45deg);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.18);
        }

        .music-toggle:focus-visible {
            outline: 3px solid rgba(170, 221, 255, 0.55);
            outline-offset: 3px;
        }

        /* 倒计时（新增，尽量不破坏原视觉） */
        .countdown {
            margin-top: 18px;
            display: flex;
            justify-content: center;
            gap: 14px;
            flex-wrap: wrap;
        }

        .unit {
            min-width: 92px;
            padding: 12px 14px 10px;
            border-radius: 14px;
            background: rgba(9, 10, 15, 0.35);
            border: 1px solid rgba(170, 221, 255, 0.18);
            backdrop-filter: blur(6px);
            box-shadow: 0 0 24px rgba(170, 221, 255, 0.10);
        }

        .num {
            font-variant-numeric: tabular-nums;
            font-size: 2.6rem;
            line-height: 1.0;
            font-weight: 600;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.95);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.25));
        }

        .label {
            margin-top: 6px;
            font-size: 0.9rem;
            letter-spacing: 4px;
            color: rgba(170, 221, 255, 0.9);
            text-transform: uppercase;
            opacity: 0.95;
        }

        @media (max-width: 520px) {
            .content { transform: translateY(0); }
            .unit { min-width: 78px; padding: 10px 12px 8px; }
            .num { font-size: 2.1rem; }
            .label { letter-spacing: 3px; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes glow {
            from { opacity: 0.7; filter: drop-shadow(0 0 5px rgba(170, 221, 255, 0.4)); }
            to { opacity: 1; filter: drop-shadow(0 0 15px rgba(170, 221, 255, 0.9)); }
        }
    </style>
</head>
<body>
    <audio id="bgm" src="./assets/fireworks.mp3" autoplay loop preload="auto" playsinline></audio>
    <button id="musicToggle" class="music-toggle" type="button" aria-label="音乐开关" aria-pressed="true" title="音乐：开">
        <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M12 3v10.55A4 4 0 1 0 14 17V7h6V3h-8z" />
        </svg>
    </button>
    <canvas id="canvas"></canvas>
    <div class="content">
        <h1 id="year">2026</h1>
        <h2>Happy New Year</h2>

        <div class="countdown" aria-label="倒计时">
            <div class="unit">
                <div class="num" id="day">--</div>
                <div class="label">Days</div>
            </div>
            <div class="unit">
                <div class="num" id="hour">--</div>
                <div class="label">Hours</div>
            </div>
            <div class="unit">
                <div class="num" id="minute">--</div>
                <div class="label">Minutes</div>
            </div>
            <div class="unit">
                <div class="num" id="second">--</div>
                <div class="label">Seconds</div>
            </div>
        </div>
    </div>

    <script>
        // Best-effort autoplay (unmuted -> muted fallback) + user toggle.
        (function () {
            var STORAGE_KEY = 'hny_bgm_muted';
            var bgm = document.getElementById('bgm');
            var toggle = document.getElementById('musicToggle');
            if (!bgm || !toggle) return;

            function updateToggleUi(isMuted) {
                toggle.classList.toggle('is-muted', !!isMuted);
                // aria-pressed=true means "on" (not muted)
                toggle.setAttribute('aria-pressed', String(!isMuted));
                toggle.title = isMuted ? '音乐：关' : '音乐：开';
            }

            function setMuted(isMuted, persist) {
                bgm.muted = !!isMuted;
                bgm.volume = 0.6;
                updateToggleUi(!!isMuted);
                if (persist) {
                    try {
                        localStorage.setItem(STORAGE_KEY, isMuted ? '1' : '0');
                    } catch (e) { }
                }
            }

            var saved = null;
            try { saved = localStorage.getItem(STORAGE_KEY); } catch (e) { }
            setMuted(saved === '1', false);

            function tryPlay() {
                var p = bgm.play();
                if (p && typeof p.then === 'function') {
                    return p.then(function () { return true; }).catch(function () { return false; });
                }
                return Promise.resolve(true);
            }

            function tryAutoPlayBestEffort() {
                return tryPlay().then(function (ok) {
                    if (ok) return true;
                    if (!bgm.muted) {
                        setMuted(true, false);
                        return tryPlay();
                    }
                    return false;
                });
            }

            window.addEventListener('load', function () {
                tryAutoPlayBestEffort();
            });

            toggle.addEventListener('click', function () {
                var nextMuted = !bgm.muted;
                setMuted(nextMuted, true);
                if (!nextMuted) {
                    tryPlay();
                }
            });
        })();

        // ===== 倒计时（新增） =====
        const elYear = document.getElementById('year');
        const elDay = document.getElementById('day');
        const elHour = document.getElementById('hour');
        const elMinute = document.getElementById('minute');
        const elSecond = document.getElementById('second');

        function pad2(n) {
            return String(n).padStart(2, '0');
        }

        function updateCountdown() {
            let today = new Date();
            let nextYear = today.getFullYear() + 1;
            let countDate = new Date(nextYear, 0, 1, 0, 0, 0, 0).getTime();
            let now = new Date().getTime();
            let gap = countDate - now;

            if (gap < 0) gap = 0;

            let second = 1000;
            let minute = second * 60;
            let hour = minute * 60;
            let day = hour * 24;

            let d = Math.floor(gap / day);
            let h = Math.floor((gap % day) / hour);
            let m = Math.floor((gap % hour) / minute);
            let s = Math.floor((gap % minute) / second);

            elYear.textContent = nextYear;
            elDay.textContent = d;
            elHour.textContent = pad2(h);
            elMinute.textContent = pad2(m);
            elSecond.textContent = pad2(s);
        }

        updateCountdown();
        setInterval(updateCountdown, 1000);

        // ===== 以下烟花/星星逻辑：完全参考 happy-new-year-particles.html =====
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let cw = window.innerWidth;
        let ch = window.innerHeight;

        // 基础配置
        const fireworks = [];
        const particles = [];
        const stars = [];
        let hue = 120; // 初始色相
        let limiterTotal = 3; // 发射频率限制（更密集）
        let limiterTick = 0;
        let timerTotal = 45; // 自动发射间隔（更密集）
        let timerTick = 0;
        let mousedown = false;
        let mx, my;

        canvas.width = cw;
        canvas.height = ch;

        // 随机数工具
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 计算距离
        function calculateDistance(p1x, p1y, p2x, p2y) {
            let xDistance = p1x - p2x;
            let yDistance = p1y - p2y;
            return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
        }

        // 星星类 (背景)
        class Star {
            constructor() {
                this.x = Math.random() * cw;
                this.y = Math.random() * ch;
                this.size = Math.random() * 2 + 2; // 稍微大一点
                this.blinkSpeed = 0.005 + Math.random() * 0.01; // 减慢闪烁速度
                this.alpha = Math.random();
                this.direction = Math.random() > 0.5 ? 1 : -1;
            }
            update() {
                this.alpha += this.blinkSpeed * this.direction;
                if (this.alpha >= 1 || this.alpha <= 0.2) { // 不完全消失
                    this.direction *= -1;
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = "white";

                // 绘制四角星
                ctx.beginPath();
                const R = this.size;
                const r = this.size * 0.4; // 内半径
                ctx.moveTo(0, -R);
                ctx.lineTo(r, -r);
                ctx.lineTo(R, 0);
                ctx.lineTo(r, r);
                ctx.lineTo(0, R);
                ctx.lineTo(-r, r);
                ctx.lineTo(-R, 0);
                ctx.lineTo(-r, -r);
                ctx.closePath();

                // 增加发光效果
                ctx.shadowBlur = 8;
                ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
                ctx.fill();

                ctx.restore();
            }
        }

        // 初始化星星
        const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
        const starCount = isMobile ? 45 : 80; // 移动设备减少星星数量
        for(let i = 0; i < starCount; i++) {
            stars.push(new Star());
        }

        // 烟花类 (升空阶段)
        class Firework {
            constructor(sx, sy, tx, ty) {
                this.x = sx;
                this.y = sy;
                this.sx = sx;
                this.sy = sy;
                this.tx = tx;
                this.ty = ty;
                this.distanceToTarget = calculateDistance(sx, sy, tx, ty);
                this.distanceTraveled = 0;
                this.coordinates = [];
                this.coordinateCount = 3;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = Math.atan2(ty - sy, tx - sx);
                this.speed = 1.7; // 降低初始速度：更慢升空
                this.acceleration = 1.02; // 降低加速度：更慢、更柔和
                this.maxSpeed = 3.2; // 限制升空最大速度
                this.brightness = random(50, 70);
                // Target pulse: flash once, then disappear.
                this.targetPulse = 0;
                this.targetPulseDuration = 50; // 延长光圈闪烁时间
                this.targetMaxRadius = 12;
            }

            update(index) {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);

                if (this.targetPulse < this.targetPulseDuration) {
                    this.targetPulse += 1;
                }

                this.speed = Math.min(this.speed * this.acceleration, this.maxSpeed);
                let vx = Math.cos(this.angle) * this.speed;
                let vy = Math.sin(this.angle) * this.speed;
                this.distanceTraveled = calculateDistance(this.sx, this.sy, this.x + vx, this.y + vy);

                if (this.distanceTraveled >= this.distanceToTarget) {
                    createParticles(this.tx, this.ty);
                    fireworks.splice(index, 1);
                } else {
                    this.x += vx;
                    this.y += vy;
                }
            }

            draw() {
                ctx.save();
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsl(' + hue + ', 100%, ' + this.brightness + '%)';
                ctx.stroke();

                // 绘制目标点光圈：只闪一次
                if (this.targetPulse > 0 && this.targetPulse <= this.targetPulseDuration) {
                    var t = this.targetPulse / this.targetPulseDuration;
                    // Smooth curves:
                    // - radius uses easeInOutSine: 0 -> 1 smoothly
                    // - alpha uses sin(pi*t): 0 -> 1 -> 0 smoothly
                    var easeInOutSine = 0.5 - 0.5 * Math.cos(Math.PI * t);
                    var pulse = Math.sin(Math.PI * t);
                    var a = Math.max(0, Math.min(1, pulse));
                    // Slightly softer: keep peak below 1
                    a = 0.85 * Math.pow(a, 1.1);
                    var r = easeInOutSine * this.targetMaxRadius;

                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.lineWidth = 2 + 1.5 * a;
                    ctx.shadowBlur = 12 + 18 * a;
                    ctx.shadowColor = 'hsla(' + hue + ', 100%, ' + this.brightness + '%, ' + (0.35 + 0.45 * a) + ')';

                    // Inner ring
                    ctx.beginPath();
                    ctx.arc(this.tx, this.ty, r, 0, Math.PI * 2);
                    ctx.strokeStyle = 'hsla(' + hue + ', 100%, ' + this.brightness + '%, ' + a + ')';
                    ctx.stroke();

                    // Soft outer ring for smoother gradient feel
                    ctx.globalAlpha = a * 0.45;
                    ctx.lineWidth = 3 + 2 * a;
                    ctx.beginPath();
                    ctx.arc(this.tx, this.ty, r + 2.5, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
                ctx.restore();
            }
        }

        // 粒子类 (爆炸阶段)
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.coordinates = [];
                this.coordinateCount = 5;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = random(0, Math.PI * 2); // 全方向爆炸
                this.speed = random(2, 12); // 提高初始速度范围：更大范围扩散
                this.friction = 0.965;
                this.gravity = 0.85;
                this.hue = random(hue - 50, hue + 50);
                this.brightness = random(50, 80);
                this.alpha = 1;
                this.decay = random(0.014, 0.018); // 更慢消散：爆炸持续更久
            }

            update(index) {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);
                this.speed *= this.friction;
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed + this.gravity;
                this.alpha -= this.decay;

                if (this.alpha <= this.decay) {
                    particles.splice(index, 1);
                }
            }

            draw() {
                ctx.save();
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, ' + this.brightness + '%, ' + this.alpha + ')';
                ctx.stroke();
                ctx.restore();
            }
        }

        function createParticles(x, y) {
            let particleCount = 100; // 增加粒子数量（更饱满）
            while (particleCount--) {
                particles.push(new Particle(x, y));
            }
        }

        function loop() {
            requestAnimationFrame(loop);

            // 颜色循环
            hue += 0.5;

            // 拖尾效果：使用 destination-out 属性让上一帧变淡而不是直接覆盖
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // 透明度越低，拖尾越长
            ctx.fillRect(0, 0, cw, ch);

            // 恢复混合模式
            ctx.globalCompositeOperation = 'lighter';

            // 绘制星星
            stars.forEach(star => {
                star.update();
                star.draw();
            });

            // 绘制烟花
            let i = fireworks.length;
            while (i--) {
                fireworks[i].draw();
                fireworks[i].update(i);
            }

            // 绘制粒子
            let j = particles.length;
            while (j--) {
                particles[j].draw();
                particles[j].update(j);
            }

            // 自动发射逻辑
            if (timerTick >= timerTotal) {
                if (!mousedown) {
                    // 随机垂直发射
                    let x = random(0, cw);
                    let y = random(0, ch / 2);
                    fireworks.push(new Firework(x, ch, x, y));
                    // 追加一发，增加密度（轻微偏移避免完全重叠）
                    let x2 = Math.min(cw, Math.max(0, x + random(-90, 90)));
                    fireworks.push(new Firework(x2, ch, x2, Math.max(0, y + random(-60, 60))));
                    timerTick = 0;
                }
            } else {
                timerTick++;
            }

            // 鼠标点击发射限制
            if (limiterTick >= limiterTotal) {
                if (mousedown) {
                    // 垂直发射：从点击位置的正下方发射
                    fireworks.push(new Firework(mx, ch, mx, my));
                    limiterTick = 0;
                }
            } else {
                limiterTick++;
            }
        }

        // 鼠标交互
        canvas.addEventListener('mousemove', function(e) {
            mx = e.pageX - canvas.offsetLeft;
            my = e.pageY - canvas.offsetTop;
        });

        canvas.addEventListener('mousedown', function(e) {
            e.preventDefault();
            mousedown = true;
        });

        canvas.addEventListener('mouseup', function(e) {
            e.preventDefault();
            mousedown = false;
        });

        // 窗口大小调整
        window.addEventListener('resize', function() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.width = cw;
            canvas.height = ch;
        });

        window.onload = loop;
    </script>
</body>
</html>
